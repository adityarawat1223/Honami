/// <reference types="node" />
import { Edge, StreamType } from './TransformerGraph';
import { Readable } from 'stream';
import { VolumeTransformer } from 'prism-media';
import type { AudioPlayer } from './AudioPlayer';
/**
 * Options that are set when creating a new audio resource.
 *
 * @template T - the type for the metadata (if any) of the audio resource.
 */
interface CreateAudioResourceOptions<T> {
    /**
     * The type of the input stream. Defaults to `StreamType.Arbitrary`.
     */
    inputType?: StreamType;
    /**
     * Optional metadata that can be attached to the resource (e.g. track title, random ID).
     * This is useful for identification purposes when the resource is passed around in events.
     * See {@link AudioResource.metadata}
     */
    metadata?: T;
    /**
     * Whether or not inline volume should be enabled. If enabled, you will be able to change the volume
     * of the stream on-the-fly. However, this also increases the performance cost of playback. Defaults to `false`.
     */
    inlineVolume?: boolean;
}
/**
 * Represents an audio resource that can be played by an audio player.
 *
 * @template T - the type for the metadata (if any) of the audio resource.
 */
export declare class AudioResource<T = unknown> {
    /**
     * An object-mode Readable stream that emits Opus packets. This is what is played by audio players.
     */
    readonly playStream: Readable;
    /**
     * The pipeline used to convert the input stream into a playable format. For example, this may
     * contain an FFmpeg component for arbitrary inputs, and it may contain a VolumeTransformer component
     * for resources with inline volume transformation enabled.
     */
    readonly pipeline: Edge[];
    /**
     * Optional metadata that can be used to identify the resource.
     */
    metadata?: T;
    /**
     * If the resource was created with inline volume transformation enabled, then this will be a
     * prism-media VolumeTransformer. You can use this to alter the volume of the stream.
     */
    readonly volume?: VolumeTransformer;
    /**
     * The audio player that the resource is subscribed to, if any.
     */
    audioPlayer?: AudioPlayer;
    /**
     * The playback duration of this audio resource, given in milliseconds.
     */
    playbackDuration: number;
    constructor(pipeline: Edge[], playStream: Readable, metadata?: T, volume?: VolumeTransformer);
    /**
     * Attempts to read an Opus packet from the audio resource. If a packet is available, the playbackDuration
     * is incremented.
     * @internal
     * @remarks
     * It is advisable to check that the playStream is readable before calling this method. While no runtime
     * errors will be thrown, you should check that the resource is still available before attempting to
     * read from it.
     */
    read(): Buffer | null;
}
/**
 * Ensures that a path contains at least one volume transforming component
 *
 * @param path - The path to validate constraints on
 */
export declare const VOLUME_CONSTRAINT: (path: Edge[]) => boolean;
export declare const NO_CONSTRAINT: () => boolean;
/**
 * Tries to infer the type of a stream to aid with transcoder pipelining.
 *
 * @param stream - The stream to infer the type of
 */
export declare function inferStreamType(stream: Readable): {
    streamType: StreamType;
    hasVolume: boolean;
};
/**
 * Creates an audio resource that can be played be audio players.
 *
 * @remarks
 * If the input is given as a string, then the inputType option will be overridden and FFmpeg will be used.
 *
 * If the input is not in the correct format, then a pipeline of transcoders and transformers will be created
 * to ensure that the resultant stream is in the correct format for playback. This could involve using FFmpeg,
 * Opus transcoders, and Ogg/WebM demuxers.
 *
 * @param input - The resource to play.
 * @param options - Configurable options for creating the resource.
 *
 * @template T - the type for the metadata (if any) of the audio resource.
 */
export declare function createAudioResource<T>(input: string | Readable, options?: CreateAudioResourceOptions<T>): AudioResource<T>;
export {};
//# sourceMappingURL=AudioResource.d.ts.map