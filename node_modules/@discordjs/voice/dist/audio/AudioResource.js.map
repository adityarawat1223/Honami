{"version":3,"file":"AudioResource.js","sourceRoot":"","sources":["../../src/audio/AudioResource.ts"],"names":[],"mappings":"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","sourcesContent":["import { Edge, findPipeline, StreamType, TransformerType } from './TransformerGraph';\nimport { pipeline, Readable } from 'stream';\nimport { noop } from '../util/util';\nimport { VolumeTransformer, opus } from 'prism-media';\nimport type { AudioPlayer } from './AudioPlayer';\n\n/**\n * Options that are set when creating a new audio resource.\n *\n * @template T - the type for the metadata (if any) of the audio resource.\n */\ninterface CreateAudioResourceOptions<T> {\n\t/**\n\t * The type of the input stream. Defaults to `StreamType.Arbitrary`.\n\t */\n\tinputType?: StreamType;\n\n\t/**\n\t * Optional metadata that can be attached to the resource (e.g. track title, random ID).\n\t * This is useful for identification purposes when the resource is passed around in events.\n\t * See {@link AudioResource.metadata}\n\t */\n\tmetadata?: T;\n\n\t/**\n\t * Whether or not inline volume should be enabled. If enabled, you will be able to change the volume\n\t * of the stream on-the-fly. However, this also increases the performance cost of playback. Defaults to `false`.\n\t */\n\tinlineVolume?: boolean;\n}\n\n/**\n * Represents an audio resource that can be played by an audio player.\n *\n * @template T - the type for the metadata (if any) of the audio resource.\n */\nexport class AudioResource<T = unknown> {\n\t/**\n\t * An object-mode Readable stream that emits Opus packets. This is what is played by audio players.\n\t */\n\tpublic readonly playStream: Readable;\n\n\t/**\n\t * The pipeline used to convert the input stream into a playable format. For example, this may\n\t * contain an FFmpeg component for arbitrary inputs, and it may contain a VolumeTransformer component\n\t * for resources with inline volume transformation enabled.\n\t */\n\tpublic readonly pipeline: Edge[];\n\n\t/**\n\t * Optional metadata that can be used to identify the resource.\n\t */\n\tpublic metadata?: T;\n\n\t/**\n\t * If the resource was created with inline volume transformation enabled, then this will be a\n\t * prism-media VolumeTransformer. You can use this to alter the volume of the stream.\n\t */\n\tpublic readonly volume?: VolumeTransformer;\n\n\t/**\n\t * The audio player that the resource is subscribed to, if any.\n\t */\n\tpublic audioPlayer?: AudioPlayer;\n\n\t/**\n\t * The playback duration of this audio resource, given in milliseconds.\n\t */\n\tpublic playbackDuration = 0;\n\n\tpublic constructor(pipeline: Edge[], playStream: Readable, metadata?: T, volume?: VolumeTransformer) {\n\t\tthis.pipeline = pipeline;\n\t\tthis.playStream = playStream;\n\t\tthis.metadata = metadata;\n\t\tthis.volume = volume;\n\t}\n\n\t/**\n\t * Attempts to read an Opus packet from the audio resource. If a packet is available, the playbackDuration\n\t * is incremented.\n\t * @internal\n\t * @remarks\n\t * It is advisable to check that the playStream is readable before calling this method. While no runtime\n\t * errors will be thrown, you should check that the resource is still available before attempting to\n\t * read from it.\n\t */\n\tpublic read(): Buffer | null {\n\t\tconst packet: Buffer | null = this.playStream.read();\n\t\tif (packet) {\n\t\t\tthis.playbackDuration += 20;\n\t\t}\n\t\treturn packet;\n\t}\n}\n\n/**\n * Ensures that a path contains at least one volume transforming component\n *\n * @param path - The path to validate constraints on\n */\nexport const VOLUME_CONSTRAINT = (path: Edge[]) => path.some((edge) => edge.type === TransformerType.InlineVolume);\n\nexport const NO_CONSTRAINT = () => true;\n\n/**\n * Tries to infer the type of a stream to aid with transcoder pipelining.\n *\n * @param stream - The stream to infer the type of\n */\nexport function inferStreamType(\n\tstream: Readable,\n): {\n\tstreamType: StreamType;\n\thasVolume: boolean;\n} {\n\tif (stream instanceof opus.Encoder) {\n\t\treturn { streamType: StreamType.Opus, hasVolume: false };\n\t} else if (stream instanceof opus.Decoder) {\n\t\treturn { streamType: StreamType.Raw, hasVolume: false };\n\t} else if (stream instanceof VolumeTransformer) {\n\t\treturn { streamType: StreamType.Raw, hasVolume: true };\n\t} else if (stream instanceof opus.OggDemuxer) {\n\t\treturn { streamType: StreamType.Opus, hasVolume: false };\n\t} else if (stream instanceof opus.WebmDemuxer) {\n\t\treturn { streamType: StreamType.Opus, hasVolume: false };\n\t}\n\treturn { streamType: StreamType.Arbitrary, hasVolume: false };\n}\n\n/**\n * Creates an audio resource that can be played be audio players.\n *\n * @remarks\n * If the input is given as a string, then the inputType option will be overridden and FFmpeg will be used.\n *\n * If the input is not in the correct format, then a pipeline of transcoders and transformers will be created\n * to ensure that the resultant stream is in the correct format for playback. This could involve using FFmpeg,\n * Opus transcoders, and Ogg/WebM demuxers.\n *\n * @param input - The resource to play.\n * @param options - Configurable options for creating the resource.\n *\n * @template T - the type for the metadata (if any) of the audio resource.\n */\nexport function createAudioResource<T>(\n\tinput: string | Readable,\n\toptions: CreateAudioResourceOptions<T> = {},\n): AudioResource<T> {\n\tlet inputType = options.inputType;\n\tlet needsInlineVolume = Boolean(options.inlineVolume);\n\n\t// string inputs can only be used with FFmpeg\n\tif (typeof input === 'string') {\n\t\tinputType = StreamType.Arbitrary;\n\t} else if (typeof inputType === 'undefined') {\n\t\tconst analysis = inferStreamType(input);\n\t\tinputType = analysis.streamType;\n\t\tneedsInlineVolume = needsInlineVolume && !analysis.hasVolume;\n\t}\n\n\tconst transformerPipeline = findPipeline(inputType, needsInlineVolume ? VOLUME_CONSTRAINT : NO_CONSTRAINT);\n\n\tif (transformerPipeline.length === 0) {\n\t\tif (typeof input === 'string') throw new Error(`Invalid pipeline constructed for string resource '${input}'`);\n\t\t// No adjustments required\n\t\treturn new AudioResource([], input, options.metadata);\n\t}\n\tconst streams = transformerPipeline.map((edge) => edge.transformer(input));\n\tif (typeof input !== 'string') streams.unshift(input);\n\n\t// the callback is called once the stream ends\n\tconst playStream = streams.length > 1 ? pipeline(streams, noop) : streams[0];\n\n\t// attempt to find the volume transformer in the pipeline (if one exists)\n\tconst volume = streams.find((stream) => stream instanceof VolumeTransformer) as VolumeTransformer | undefined;\n\n\treturn new AudioResource(transformerPipeline, (playStream as any) as Readable, options.metadata, volume);\n}\n"]}