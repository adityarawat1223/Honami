"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseLocalPacket = exports.VoiceUDPSocket = void 0;
const dgram_1 = require("dgram");
const events_1 = require("events");
const net_1 = require("net");
/**
 * Manages the UDP networking for a voice connection.
 */
class VoiceUDPSocket extends events_1.EventEmitter {
    /**
     * Creates a new VoiceUDPSocket.
     *
     * @param remote - Details of the remote socket
     */
    constructor(remote) {
        super();
        this.socket = dgram_1.createSocket('udp4');
        this.socket.on('error', (error) => this.emit('error', error));
        this.remote = remote;
    }
    /**
     * Sends a buffer to Discord.
     *
     * @param buffer - The buffer to send
     */
    send(buffer) {
        return this.socket.send(buffer, this.remote.port, this.remote.ip);
    }
    /**
     * Closes the socket, the instance will not be able to be reused.
     */
    destroy() {
        this.socket.close();
    }
    /**
     * Performs IP discovery to discover the local address and port to be used for the voice connection.
     *
     * @param ssrc - The SSRC received from Discord
     */
    performIPDiscovery(ssrc) {
        return new Promise((resolve, reject) => {
            const listener = (message) => {
                try {
                    const packet = parseLocalPacket(message);
                    this.socket.off('message', listener);
                    resolve(packet);
                }
                catch { }
            };
            this.socket.on('message', listener);
            this.socket.once('close', () => reject(new Error('Cannot perform IP discovery - socket closed')));
            const discoveryBuffer = Buffer.alloc(70);
            discoveryBuffer.writeUInt32BE(ssrc, 0);
            this.send(discoveryBuffer);
        });
    }
}
exports.VoiceUDPSocket = VoiceUDPSocket;
/**
 * Parses the response from Discord to aid with local IP discovery.
 *
 * @param message - The received message
 */
function parseLocalPacket(message) {
    const packet = Buffer.from(message);
    let ip = '';
    for (let i = 4; i < packet.indexOf(0, i); i++)
        ip += String.fromCharCode(packet[i]);
    if (!net_1.isIPv4(ip)) {
        throw new Error('Malformed IP address');
    }
    const port = parseInt(packet.readUIntLE(packet.length - 2, 2).toString(10), 10);
    return { ip, port };
}
exports.parseLocalPacket = parseLocalPacket;
//# sourceMappingURL=VoiceUDPSocket.js.map